# vert.x 왜 쓰는가???
- 외부 서버와 비동기로 트래픽을 최소화 하여 데이터를 주고 받기 위해 여기선 vert.x 하젤케스트, spring integration messaging channel를 이용하고 있다. 
- 블록체인 ico를 위해 redis로 트래픽을 최소화 하고자 설계했던 모델과 channel를 두어 메세징을 처리했다는점이 유사하게 느껴진다. 
- 그런데 귀에 익숙한 vert.x애는 뭐고 애는 내가 원하는 걸 구현하는데 어떤 도움을 줄 수 있는 녀석일까?

## 현재 처한 시스템 특성
- 외부의 서비스 서버에선 live 영상 데이터 외 기타 vod데이터도 내려준다.
- 외부의 서버는 우리 부서외 다른 부서의 서비스 api도 지원하기 때문에 적절한 트래픽 분산이 필요하다.
- live 영상을 받아야 하고,, live시 몰리는 요청 데이터 처리를 원활히 수행하기 위해선 비동기 서버 모델이 필요한 것으로 보인다.  (채팅 서비스도 제공 중이다.)
- 장애처리를 실시간으로 하는 것도 중요하다.(웹소켓사용)

## vert.x
- 서버 프레임워크
- 고성능과 다양한 프로토콜 지원 장점
- 서버 네트워크 환경을 구축하고 운영하는 환경까지 고려함
- vert.x는 하나의 '서버 프로세스 데몬'을 제작하는 것 뿐만 아니라 클러스터링 환경에서 동작하는 여러 서버 프로세스 데몬을 제작하는 방법에 대한 고민도 하고 있다.
- 그렇기 때문에 vert.x가 어떤 방식으로 고성능을 내고 있는지, 어떤 네트워크 환경을 고려하고 있는지 알아볼 가치가 있따..

## 특징

- vert.x는 nodejs로부터 영향을 받은 프로젝트다. 즉, node.js처럼 **Event-based 프로그래밍 모델**을 제공하는 서버 프레임워크이다.  둘다 모두 비동기 형태의 API를 제공한다.
- vert.x의 철학은
    - polyglot 여러 언어 지원
    - super simple concurrency model - vert.x는 사용자가 작성한 코드가 동일한 스레드에서만 실행됨을 보장하기 때문에 더 이상 synchronized나 volatile 같은 동기화를 위한 locking 처리를 신경 쓰지 않아도 된다.
    - Event-bus 제공 : vert.x의 목표는 '하나의 서버 프로세스 데몬'을 만드는 것에 그치지 않는다. vert.x로 만든 여러 서버 프로그램이 서로 원활하게 통신하게 하는 것까지도 목표에 두고 있다. 이를 위해 **vert.x는 Event Bus를 제공한다. Point to Point나 Pub/Sub 같은 MQ 기능을 사용할 수 있다(Event Bus 기능을 제공하기 위해 vert.x는 Hazelcast라는 IMDG를 사용한다).** 이런 Event Bus가 있기 때문에 서로 다른 언어로 작성된 서버 애플리케이션이 용이하게 통신할 수 있다.
    - Module System & Public Module Repository : vert.x에는 모듈 시스템이라는 것이 있다. 모듈 시스템은 일종의 컴포넌트로 이해할 수 있다. vert.x로 만든 서버 어플리케이션 프로젝트 자체를 모듈화한 것이다.

    ## vert.core

    - vert.x의 대략적인 아키텍처
     
    

## reference

- [https://d2.naver.com/helloworld/163784](https://d2.naver.com/helloworld/163784)

- 아는 것보단, 할 수 있는게 중요하다.
- 개발도구를 잘 활용하는 능력은 생산성과 직결되기에 중요합니다. 그런데 개발도구를 '배워야'하는 개발자보다는 스스로 익힐 수 있고, 적절한 도구를 선택할 수 있는 개발자가 현장에서는 필요합니다. 특정 개발도구를 익혔다는 사실은 단기적으로는 실력이라고 할 수 있습니다. 새로운 도구가 나왔을 때도 적응할 수 있는 학습력/적응력/판단력이 본질이고 이것이 누적되어 실력이 됩니다.
