- 프론트엔드 라우팅 시스템에서 서버에 요청을 날리지 않고 브라우저 화면을 바꾸기 위해 아래 두가지가 사용된다. 
   
#### hash 
- `#` 심볼이 있는 url. 
- 해당 url은 http request를 포함하지 않기 때문에 백엔드에 영향을 주지 않고 페이지를 리로드 하지 않는다.
	
#### hisotry 
- html5 history interface인 pushState()와 replaceState()를 사용한다. 
- 둘다 브라우저의 히스토리 stack에 적용된다. (back, forward, go) (?) url이 변경되어도, 브라우저가 백엔드에 즉시 요청을 보내지 않는다. 
- [하지만 history 모드의 경우 필요한 설정이 있다.](https://router.vuejs.org/kr/guide/essentials/history-mode.html#%EC%84%9C%EB%B2%84-%EC%84%A4%EC%A0%95-%EC%98%88%EC%A0%9C)  
	* 발생할 수 있는 문제   
	 
```
그러나 문제는 다음과 같습니다. 우리의 앱이 적절한 서버 설정이 없는 단일 페이지 클라이언트 앱이기 때문에 사용자가 직접 http://oursite.com/user/id 에 접속하면 404 오류가 발생합니다.
```

- 브라우저에 url을 클릭하면 발생하는 현상....
   => dns서버에서 요청한 url(ip, domain의 타겟 서버를 추적한다) => 즉 서버에 path가 등록되어 있어야 한다. 
   => 하지만, vue-router에 등록한 path은 서버에 등록된 경로가아닌 클라이언트 사이드에서 등록한 path이기 때문에 서버에서 인식하지 못한다. 즉 url를 인식하지 못한다. 
   => **그렇기 때문에 history 모드일 경우 서버에 설정을 해놓아야 한다. **    
 
 - 공식 사이트에서 제공해주는 해결 법 
```
 문제를 해결하려면 서버에 간단하게 포괄적인 대체 경로를 추가하기만 하면됩니다. URL이 정적 에셋과 일치하지 않으면 앱이 있는 동일한 index.html페이지를 제공해야 합니다.    
```
   
#### 클라이언트 사이드 라우팅  
- 클라이언트 쪽 라우팅은 사용자가 응용 프로그램 또는 웹 사이트를 탐색 할 때 페이지의 URL이 변경 되어도 전체 페이지를 다시로드하지 않는 라우팅 유형입니다.
- 서버에 영향을 주지 않는다? 대신 JavaScript는 URL을 업데이트하고 새 컨텐츠를 가져 와서 표시하는 데 사용됩니다.

#### hash mode and history mode
- history모드는 서버 설정이 따로 필요하다. 
  * 현재 프로젝트 구조에서 history모드로 바꾸게 되면 스크롤이 문제가 생길 수 있다. 

#### 라우팅?
- 라우팅 주체는 서버가 될 수 도 있고 브라우저가 될 수도 있다. 
  * 서버 라우팅 : 매번 주소를 요청할 때 마다 화면 갱신 (네이버, 구글)  
 
  * 브라우저 라우팅 : 주소를 매번 요청하더라도 화면이 갱신되지 않는다. 대신에 화면에 필요한 데이터만 서버에 따로 요청하여 갱신하는 방법을 사용한다. (api를 요청해서 화면에 그린다)  (구글메일, 트렐로) 

	 - 브라우저 라우팅시 #가 붙는다. 
		- 크롬같은 경우는 history모드가 있기 때문에 history를 사용한다. ?? (강의 내용 ) 
